# Integration Testing with REST Clients

HTTP services ship a TypeScript client package (`rest-js`) that serves two purposes:

1. **Client stubs** — typed wrappers around every HTTP endpoint, published as an npm package for external
   consumers.
2. **Integration tests** — end-to-end tests that exercise the full service stack through the client stubs.

> gRPC services expose their public API through Go packages instead
> (see [packaging documentation](./6.packaging.md)).

## Workspace layout

The TypeScript code lives inside the Go repository as a [pnpm workspace](https://pnpm.io/workspaces):

```
pnpm-workspace.yaml
pkg/
  rest-js/            ← client library (published)
  rest-js-test/       ← test helpers (published)
  test/rest-js/       ← integration test suite (private)
```

- **`rest-js`** — the publishable client (`@a-novel/service-[name]-rest`). Contains the API class,
  endpoint functions, and [Zod](https://zod.dev/) schemas.
- **`rest-js-test`** — reusable test utilities (e.g., user registration helpers, email checking). Also
  published so that other services' test suites can set up dependencies.
- **`test/rest-js`** — the actual test files. Marked `private: true` — never published.

## Client library

### API class

Each client defines a base class that wraps a service URL and exposes two fetch helpers:

```typescript
export class ServiceApi {
  private readonly _baseUrl: string;

  constructor(baseUrl: string) {
    this._baseUrl = baseUrl;
  }

  async fetchVoid(input: string, init?: RequestInit): Promise<void> {
    await fetch(`${this._baseUrl}${input}`, init).then(handleHttpResponse);
  }

  async fetch<T>(input: string, validator?: ZodType<T>, init?: RequestInit): Promise<T> {
    return await fetch(`${this._baseUrl}${input}`, init)
      .then(handleHttpResponse)
      .then(validator ? decodeHttpResponse(validator) : decodeRawHttpResponse<T>);
  }
}
```

`handleHttpResponse` and `decodeHttpResponse` come from
[`@a-novel-kit/nodelib-browser`](https://github.com/a-novel-kit/nodelib-browser). When a Zod validator
is provided, the response body is parsed and validated automatically.

Infrastructure endpoints (ping, healthcheck) can be defined as class methods directly.

### Endpoint functions

Each endpoint is a standalone async function that receives the API instance as its first argument:

```typescript
export async function entityGet(api: ServiceApi, accessToken: string, form: EntityGetRequest): Promise<Entity> {
  const params = new URLSearchParams();
  params.set("id", form.id);

  return await api.fetch(`/entity?${params.toString()}`, EntitySchema, {
    headers: { ...HTTP_HEADERS.JSON, Authorization: `Bearer ${accessToken}` },
    method: "GET",
  });
}
```

The pattern is always the same: build URL parameters or a JSON body, call `api.fetch` or `api.fetchVoid`,
and return the typed result.

### Zod schemas

Request and response shapes are defined as Zod schemas, with TypeScript types inferred from them:

```typescript
export const EntitySchema = z.object({
  id: z.string(),
  name: z.string(),
  createdAt: z.iso.datetime().transform((value) => new Date(value)),
});

export type Entity = z.infer<typeof EntitySchema>;
```

These schemas must match the [OpenAPI spec](./7.openapi.md) — same fields, same types, same constraints.
Shared validation constants (min/max lengths, enums) are defined in a separate `const.ts` / `form.ts` file
and reused across both schemas and request types.

### Barrel exports

A single `src/index.ts` re-exports everything:

```typescript
export * from "./api";
export * from "./entity";
export * from "./form";
export * from "./const";
```

## Test helpers

The `rest-js-test` package provides reusable utilities for common test setup operations (e.g., registering
a user, checking a sent email). These helpers call the client stubs internally:

```typescript
export async function registerUser(api: ServiceApi, data: PreRegisterData) {
  const password = generateRandomPassword();
  const anonToken = await tokenCreateAnon(api);

  const token = await entityCreate(api, anonToken.accessToken, {
    email: data.email,
    password,
    shortCode: data.shortCode,
  });

  const claims = await claimsGet(api, token.accessToken);

  return { email: data.email, password, claims, token };
}
```

Test helpers are published as a separate package so that **other services** depending on this one can
use them in their own integration test suites.

### Email verification

When the service sends emails (registration, password reset, etc.), tests verify them through a mock
SMTP server ([Mailpit](https://github.com/axllent/mailpit)). The helper polls Mailpit's search API,
parses the raw email, extracts links from the HTML body, and optionally deletes the message after
consumption:

```typescript
export async function checkEmail(mailHost: string, search: string): Promise<ParsedMail> {
  const messageID = await vi.waitFor(async () => {
    const res = await fetch(`${mailHost}/api/v1/search?query=${search}&limit=1`, { ... });
    // ...
    return searchRes.messages[0].ID;
  }, { timeout: 1000 });

  // Fetch raw message, delete it, parse with mailparser.
  return await simpleParser(rawContent);
}
```

## Integration tests

### Infrastructure

Tests run against a local instance of the full service stack, managed through
[Podman Compose](https://github.com/containers/podman-compose). The compose file spins up all required
containers:

```yaml
services:
  mailserver: # Mailpit — mock SMTP server
  postgres-service: # PostgreSQL database (built from local Dockerfile)
  dependency-service: # Any dependent service (pre-built image)
  service: # The service under test (built from local Dockerfile)
    ports:
      - "${API_PORT}:8080"
```

Environment variables (`.envrc`) configure the connection:

```bash
export API_PORT=4011
export API_URL="http://localhost:${API_PORT}"
export MAIL_TEST_HOST="http://localhost:${MAIL_UI_TEST_PORT}"
```

The test lifecycle is handled by a shell script invoked from the Makefile:

```bash
# Start all containers.
podman compose -f "${PODMAN_FILE}" up -d --build
# Run tests.
pnpm test
# Tear down.
podman compose -f "${PODMAN_FILE}" down --volume
```

```makefile
test-pkg-js:
	bash -c "set -m; bash '$(CURDIR)/scripts/test.pkg.js.sh'"
```

### Vitest configuration

Tests use [Vitest](https://vitest.dev/). The root `vitest.config.ts` maps workspace package names to
their source directories so tests import from source rather than built artifacts:

```typescript
export default defineConfig({
  test: {
    environment: "jsdom",
    alias: {
      "@a-novel/service-[name]-rest": resolve("./pkg/rest-js/src/index"),
      "@a-novel/service-[name]-rest-test": resolve("./pkg/rest-js-test/src/index"),
    },
    coverage: {
      include: ["pkg/rest-js/src/**/*.{ts,tsx}"],
    },
    projects: [{ root: "pkg/test/rest-js", extends: true }],
  },
});
```

### Writing tests

Each test file covers a logical group of endpoints. Tests should mirror the
[OpenAPI spec](./7.openapi.md): one `describe` block per operation, covering both success and error
paths with the expected HTTP status codes.

```typescript
describe("entityGet", () => {
  it("returns an existing entity", async () => {
    const api = new ServiceApi(process.env.API_URL!);

    // Set up: create the entity first.
    const user = await registerUser(api, await preRegisterUser(api, process.env.MAIL_TEST_HOST!));

    const adminToken = await tokenCreate(api, {
      email: process.env.SUPER_ADMIN_EMAIL!,
      password: process.env.SUPER_ADMIN_PASSWORD!,
    });

    const entity = await entityGet(api, adminToken.accessToken, {
      id: user.claims.userID!,
    });

    expect(entity.email).toBe(user.email);
  });

  it("returns 404 for a non-existing entity", async () => {
    const api = new ServiceApi(process.env.API_URL!);

    const adminToken = await tokenCreate(api, {
      email: process.env.SUPER_ADMIN_EMAIL!,
      password: process.env.SUPER_ADMIN_PASSWORD!,
    });

    await expectStatus(entityGet(api, adminToken.accessToken, { id: crypto.randomUUID() }), 404);
  });
});
```

Key conventions:

- **`expectStatus`** (from `@a-novel-kit/nodelib-test/http`) asserts that a promise rejects with a
  specific HTTP status code.
- Each test creates its own `ServiceApi` instance from `process.env.API_URL`.
- Tests must be self-contained: they create their own data (users, tokens) rather than relying on
  shared state between tests.
- Error cases should verify the exact HTTP status codes documented in the OpenAPI spec (401, 403, 404,
  409, 422, etc.).
