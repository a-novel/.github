# Layers

Each A-Novel service follows a three-layer architecture: **DAO**, **Services**, and **Handlers**.

> The layered architecture enforces **separation of concerns**, making code easier to test, maintain, and evolve.

## Clean Architecture

This architecture is based on [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html),
a set of principles introduced by Robert C. Martin (Uncle Bob). Clean Architecture organizes code into concentric
layers, with business logic at the center and external concerns (databases, frameworks, UI) at the periphery.

We don't strictly follow the Clean Architecture principles. We use three main layers:

```
┌─────────────────────────────────────────────────────┐
│                   Handlers Layer                    │
│                    (handlers/)                      │
│                                                     │
│  • Request parsing, validation, response formatting │
└──────────────────────────┬──────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────┐
│                    Service Layer                    │
│                     (services/)                     │
│                                                     │
│  • Business logic, orchestration                    │
│  • Transaction management                           │
│  • Input validation, error handling                 │
└──────────────────────────┬──────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────┐
│                  Data Access Layer                  │
│                       (dao/)                        │
│                                                     │
│  • External data source abstraction                 │
│  • Query execution and response mapping             │
└──────────────────────────┬──────────────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        ▼                  ▼                  ▼
   PostgreSQL            LLMs          Other sources
```

Two additional (but optional) layers may also be used:

- `/lib` for shared code that does not belong to a specific layer.
  - This layer should be kept minimal. If any of its members is to be duplicated among multiple projects,
    make sure it does not already exist in the shared [golib](https://github.com/a-novel-kit/golib).
    Otherwise, add a `#TODO` to move it there at some point.
- `/models` for shared definitions and data structure (mails, migrations, enums, etc.)
  - Only shared go types should live at the root of the `/models` layer. Other data structures should be placed
    inside a descriptive subfolder (`/models/mails`, `/models/migrations`, etc.)

### The Dependency Rule

The foundational principle of Clean Architecture is the **Dependency Rule**:

> Source code dependencies can only point inwards.

Inner layers take care of the implementation details, while outer layers abstract them through a mockable interface.

Each layer exposes its members as what we call "exec structs" i.e., structs with a single public method called `Exec`.
Those `Exec` methods usually take a context and a locally defined request struct as parameters. It should return a
business object, which may be defined locally or shared with other methods under the same layer.

```go
package layer

import (
	"context"
)

type MyMethodRequest struct {
	// ...
}

type MyMethod struct {
	// ... Dependencies
}

func (layer *MyMethod) Exec(ctx context.Context, request *MyMethodRequest) (*BusinessEntity, error) {
	// Implementation.
}
```

To declare dependencies, a method must create its own interfaces. Those interfaces are mocked using
[mockery](https://github.com/vektra/mockery) (more about that in the [unit tests documentation](./3.testing.md)).
The provided interfaces must match the signature of the lower layer (importing definitions from bottom to top is
allowed). Those interfaces must be properly prefixed with the method name:

```go
package layer

type MyMethod[Layer][ImportedMethod] interface {
	Exec(...)
}
```

For example:

```go
package layer

// [ModuleCreate] => name of the current method
// [Repository] => refers to the DAO layer
// [ModuleExists] => refers to the Delete method of the Repository layer
//
// This would create a dependency on the ModuleExists DAO from the ModuleCreate
// service.
type ModuleCreateRepositoryModuleExists interface {
	Exec(...)
}
```

Note that name can be shortened if the layers business targets match.

```go
package layer

// Module and Workflow are different business targets, keep name full.
type ModuleCreateRepositoryWorkflowExists interface {
	Exec(...)
}

// In place of ModuleCreateRepositoryModuleExists, since both the dependency
// and the service operate on the Module entity.
type ModuleCreateRepositoryExists interface {
	Exec(...)
}

// If the ModuleCreate service depends on the ModuleCreate repository,
// then the suffix may be omitted entirely.
type ModuleCreateRepository interface {
	Exec(...)
}
```

#### External connections

Dependencies MUST BE internal, except in the `/pkg` files. However, some layers may require connections, i.e.,
interact with separate services (that must be run as part of the containerized processes). Those connections (postgres,
openai, etc.) are not methods of a layer, so they cannot be mocked the conventional way.

For this case, a connection must be passed through the context.

> Passing connections through the context allows a different kind of mocking, by injecting a connection with the
> desired parameters, without any control from the layer itself. For example, the context may expect a postgres
> connection; whether this connection is a direct connection or a transactional one is up to the caller.
> Production code can use direct connections, and tests can provide a transaction that can be safely rolled back,
> once the test is over.

Each connection should provide dedicated helpers for initialization and interactions. Those helpers can either be
retrieved from an external package or loaded from the `/lib` layer.

```go
// Use tx to perform queries.
tx, err := postgres.GetContext(ctx)
```

### Layer factories

Each layer provides a factory method to create its exec structs. This prevents the need for dependencies to be exposed
onto the main struct (which could also lead to side effects if those are unintentionally modified at runtime).

```go
package layer

type MyMethodDependency1 interface {
	// ... Dependencies
}

type MyMethodDependency2 interface {
	// ... Dependencies
}

type MyMethod struct {
	dependency1 MyMethodDependency1
	dependency2 MyMethodDependency2
}

func NewMyMethod(
	dependency1 MyMethodDependency1,
	dependency2 MyMethodDependency2,
) *MyMethod {
	return &MyMethod{
		dependency1: dependency1,
		dependency2: dependency2,
	}
}
```

### Naming

Naming methods is less restricted, but usually one exec struct will operate a simple operation over a single
business object / entity. So the recommended naming scheme is `[Entity][Action]`: `UserList`, `ModuleCreate`, etc.

Files should be named after the exec struct they define. For example, the `ModuleCreate` struct should live inside
the `moduleCreate.go` file.

Some layers have huge ties to a particular dependency. For example, DAO structs are either tied to a database
(postgres, redis) or another source (ai). To help with debugging, the relevant dependency can be used as a prefix
to the file name.

- `ai.[method].go`, `postgres.[method].go` for the DAO
- `http.[method].go`, `grpc.[method].go` for the handlers

### Linkage

Dependencies are never directly linked in the code. Instead, the main routine is responsible for calling the factories
for each layer and branching on the result.

Linkage may happen in:

- The main functions (located under `cmd/`, they are run as part of the containerized processes)
- Mocks inside test files (see [unit tests documentation](./3.testing.md))
- Inside the exported libraries (`/pkg`). In this case (and this case only), the required dependencies may exist outside
  the layers entirely (external instances).

## Layer specifics

Layers are located under `/internal`. This is a special go directory that prevents its contents from being exposed
publicly. Layers are not meant to be shared between projects. For this, you must wrap them in a public library, under
`/pkg`.

### DAO

The lowest layer, used to interact with data sources. Albeit not always true, this data source is most often postgres.

For postgres, we use [bun](https://bun.uptrace.dev/guide/), an ORM that has the benefit of integrating many tools under
the same package (struct serialization, migrations, etc.).

> About ORMs: we choose not to use bun query builder and instead rely on raw postgres queries. ORMs have a lot of
> drawbacks that are not worth the added complexity. We also want to prevent building our own internal ORM (which a
> lot of anti-ORM companies end up doing anyway). Queries are written in SQL, and bun is only used for its other
> capabilities (namely, struct serialization / deserialization, and migrations). The query builder is still used in
> tests, for simplicity.

DAO revolves around schemas, and operations on those schemas. The first step is to define a model for a given table,
and implement [bun models](https://bun.uptrace.dev/guide/models.html) on them. The DAO file structure should resemble
this:

```txt
- dao/
  - pg.[entity].go
  - pg.[entity][action].sql
  - pg.[entity][action].go
```

Where action is an operation (insert, update, exists, list, search, etc.). The `pg.[entity][action].go` will usually
look like this:

```go
package dao

import (
	"context"
	_ "embed"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/uptrace/bun/driver/pgdriver"

	"github.com/a-novel-kit/golib/postgres"
)

//go:embed pg.[entity][action].sql
var entityActionQuery string

type EntityActionRequest struct {
	// ...
}

type EntityAction struct{}

func NewEntityAction() *EntityAction {
	return new(EntityAction)
}

func (repository *EntityAction) Exec(
	ctx context.Context, request *EntityActionRequest,
) (*[entity], error) {
	tx, err := postgres.GetContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("get transaction: %w", err)
	}

	entity := new([entity])

	err = tx.NewRaw(
		entityActionQuery,
		// ...
	).Scan(ctx, entity)
	if err != nil {
		// ... Handle errors.

		return nil, fmt.Errorf("execute query: %w", err)
	}

	return entity, nil
}
```

- Embed the query file
- Load transaction from context
- Create entity
- Execute query and retrieve entity
- Return results

### Services

The middle layer, responsible for business logic and orchestration. Services validate incoming requests and coordinate
calls to lower layers (usually DAOs) to fulfill a business operation.

Services handle **request validation** using the
[go-playground/validator](https://pkg.go.dev/github.com/go-playground/validator/v10) library. Validation is struct-based:
rules are declared as tags on request fields and checked at the beginning of every `Exec` call. The service file
structure should resemble this:

```txt
- services/
  - validate.go
  - [entity].go
  - [entity][action].go
```

Where `validate.go` sets up the validator instance and registers custom validations, `[entity].go` defines shared
response types for a given entity, and `[entity][action].go` implements a single operation.

#### Validation setup

The validator is initialized once at the package level. Custom validation rules can be registered in an `init()` block:

```go
package services

import (
	"errors"

	"github.com/go-playground/validator/v10"
)

var validate = validator.New(validator.WithRequiredStructEnabled())

var ErrInvalidRequest = errors.New("invalid request")

func init() {
	err := validate.RegisterValidation("myRule", MyCustomValidator)
	if err != nil {
		panic(err)
	}
}
```

#### Service anatomy

A simple service that orchestrates a single DAO call will usually look like this:

```go
package services

import (
	"context"
	"errors"
	"fmt"

	"[project]/internal/dao"
)

type EntityActionDependency1 interface {
	Exec(...)
}

type EntityActionRequest struct {
	Value string `validate:"..."`
}

type EntityAction struct {
  dependency1 EntityActionDependency1
}

func (service *EntityAction) Exec(ctx context.Context, request *EntityActionRequest) (bool, error) {
	// Validate request. Always comes first.
	err := validate.Struct(request)
	if err != nil {
		return false, errors.Join(err, ErrInvalidRequest)
	}

	// Orchestrate lower layer call.
	service.dependency1.Exec(...)
}
```

- Define a request struct with `validate` tags
- Call `validate.Struct(request)`
- Call lower layers

#### Context management

Service are also tasked with context management to a certain level. For example, calling multiple repositories in a
single transaction.

In this case, the service layer (and service layer alone) is allowed to break isolation, boundaries, and manage
the transaction itself.

```go
err = postgres.RunInTx(ctx, nil, func(ctx context.Context, tx bun.IDB) error {
	service.dependency1.Exec(...)
	service.dependency2.Exec(...)
	return nil
})
```

### Handlers

The outermost layer, responsible for exposing the service layer over a transport protocol. Handlers parse incoming
requests, delegate to a service, and format the response (or error) according to the protocol conventions.

A handler never contains business logic. Its job is strictly limited to:

- **Parsing** the incoming request into a service-layer request struct
- **Calling** a single service
- **Mapping errors** returned by the service to protocol-appropriate status codes
- **Formatting** the response back to the caller

The handler file structure should resemble this:

```txt
- handlers/
  - [protocol].[entity].go
  - [protocol].[entity][action].go
```

Where `[protocol].[entity].go` defines shared response types and mapping helpers for a given entity, and
`[protocol].[entity][action].go` implements a single handler.

#### Handler anatomy

Regardless of the transport protocol (HTTP, gRPC, ...), every handler follows the same pattern:

```go
package handlers

import (
	"context"

	"[project]/internal/services"
)

type EntityActionService interface {
	Exec(ctx context.Context, request *services.EntityActionRequest) (*services.Entity, error)
}

type EntityAction struct {
	service EntityActionService
}

func NewEntityAction(service EntityActionService) *EntityAction {
	return &EntityAction{service: service}
}
```

The handler then exposes a method whose signature depends on the protocol. Inside, the flow is always:

1. Parse the protocol-specific request into a service request
2. Call `handler.service.Exec(...)`
3. Map errors to protocol status codes
4. Map the service response to a protocol-specific response

#### Response DTOs (Data Transfer Objects)

Handlers define their own response types, separate from the service layer. A mapping helper converts service
objects into handler DTOs:

```go
package handlers

type Entity struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func loadEntity(s *services.Entity) Entity {
	return Entity{
		ID:   s.ID.String(),
		Name: s.Name,
	}
}
```

This keeps serialization concerns (json tags, field selection, formatting) inside the handler layer.

#### Error mapping

Each handler maps domain errors to protocol-appropriate status codes. The handler is the only place
where this translation happens. Sentinel errors from the service or DAO layers are matched using `errors.Is()`
and converted to a relevant status.

#### HTTP handlers

HTTP handlers implement the `http.Handler` interface via `ServeHTTP(w http.ResponseWriter, r *http.Request)`.
Request parsing depends on the HTTP method:

- **POST/PUT** (body): parse JSON with `encoding/json`
- **GET** (query params): parse with [gorilla/schema](https://github.com/gorilla/schema), using `schema` struct tags

```go
// Query parameter decoder, shared across all HTTP handlers.
var muxDecoder = schema.NewDecoder()
```

For GET handlers, define a request struct with `schema` tags. The decoder maps query parameters to struct fields
automatically, including typed values (`uuid.UUID`, `int`, slices, etc.):

```go
type EntityListRequest struct {
	Limit  int      `schema:"limit"`
	Offset int      `schema:"offset"`
	Roles  []string `schema:"roles"`
}
```

```go
func (handler *EntityList) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	var request EntityListRequest

	err := muxDecoder.Decode(&request, r.URL.Query())
	if err != nil {
		httpf.HandleError(r.Context(), handler.logger, w, nil, httpf.ErrMap{nil: http.StatusBadRequest}, err)
		return
	}

	// request.Limit, request.Offset, request.Roles are ready to use.
}
```

A typical HTTP handler (POST):

```go
package handlers

import (
	"context"
	"encoding/json"
	"net/http"

	"github.com/a-novel-kit/golib/httpf"

	"[project]/internal/services"
)

type EntityActionService interface {
	Exec(ctx context.Context, request *services.EntityActionRequest) (*services.Entity, error)
}

type EntityActionRequest struct {
	Field1 string `json:"name"`
}

type EntityAction struct {
	service EntityActionService
}

func NewEntityAction(service EntityActionService) *EntityAction {
	return &EntityAction{service: service}
}

func (handler *EntityAction) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Parse request body.
	decoder := json.NewDecoder(r.Body)

	var request EntityActionRequest

	err := decoder.Decode(&request)
	if err != nil {
		httpf.HandleError(r.Context(), handler.logger, w, nil, httpf.ErrMap{nil: http.StatusBadRequest}, err)
		return
	}

	// Call service.
	res, err := handler.service.Exec(r.Context(), &services.EntityActionRequest{
		Field1: request.Field1,
	})
	if err != nil {
		httpf.HandleError(r.Context(), handler.logger, w, nil, httpf.ErrMap{
			services.ErrInvalidRequest:  http.StatusUnprocessableEntity,
			dao.ErrEntityAlreadyExists:  http.StatusConflict,
		}, err)
		return
	}

	// Send response.
	httpf.SendJSON(r.Context(), w, nil, loadEntity(res))
}
```

Error mapping uses `httpf.HandleError` from [golib](https://github.com/a-novel-kit/golib). The `httpf.ErrMap` is
a `map[error]int`: each sentinel error maps to an HTTP status code. A `nil` key defines the default status for
any unmatched error. If no `nil` key is present and the error does not match, it defaults to `500 Internal Server Error`.

#### gRPC handlers

gRPC handlers embed the generated `Unimplemented*Server` stub and implement the RPC method directly.

##### Proto schemas

[Proto files documentation](https://protobuf.dev/programming-guides/proto3/)

Proto definitions live under `internal/models/proto/`. Each service defines a **single RPC** in its own `.proto`
file. Shared messages and enums can be defined in a separate `.proto` file and imported where needed:

```protobuf
syntax = "proto3";

import "entity.proto";

service EntityGetService {
  rpc EntityGet(EntityGetRequest) returns (EntityGetResponse);
}

message EntityGetRequest {
  string id = 1;
}

message EntityGetResponse {
  Entity entity = 1;
}
```

Go stubs are generated using [buf](https://buf.build/) into `internal/handlers/protogen/`. The generation is
configured via `buf.yaml` and `buf.gen.yaml` at the project root, and triggered by running:

```sh
make generate
```

This produces two files per proto definition:

- `<name>.pb.go` — message and enum types
- `<name>_grpc.pb.go` — gRPC client/server interfaces, `Unimplemented*Server` stubs, and `Register*Server` functions

##### Handler implementation

A typical gRPC handler:

```go
package handlers

import (
	"context"
	"errors"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"[project]/internal/handlers/protogen"
	"[project]/internal/services"
)

type EntityActionService interface {
	Exec(ctx context.Context, request *services.EntitySelectRequest) (*services.Entity, error)
}

type EntityAction struct {
	protogen.UnimplementedEntityActionServiceServer

	service EntityActionService
}

func NewEntityAction(service EntityActionService) *EntityAction {
	return &EntityAction{service: service}
}

func (handler *EntityAction) EntityAction(
	ctx context.Context, request *protogen.EntityActionRequest,
) (*protogen.EntityActionResponse, error) {
	// Parse protobuf request.
	entityID, err := uuid.Parse(request.ActionId())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, "invalid entity id")
	}

	// Call service.
	entity, err := handler.service.Exec(ctx, &services.EntitySelectRequest{
		ID: entityID,
	})
	if errors.Is(err, dao.ErrEntitySelectNotFound) {
		return nil, status.Error(codes.NotFound, "entity not found")
	}
	if err != nil {
		return nil, status.Error(codes.Internal, "internal error")
	}

	// Map response to protobuf.
	return &protogen.EntityActionResponse{
		Entity: &protogen.Entity{
			Id:   entity.ID.String(),
			Name: entity.Name,
		},
	}, nil
}
```

Error mapping uses `google.golang.org/grpc/status` and `google.golang.org/grpc/codes`. Each domain error is matched
with `errors.Is()` and translated to the appropriate gRPC status code. Any unmatched error returns
`codes.Internal`.
