# Layers

Each A-Novel service follows a three-layer architecture: **DAO**, **Services**, and **Handlers**.

> The layered architecture enforces **separation of concerns**, making code easier to test, maintain, and evolve.

## Clean Architecture

This architecture is based on [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html),
a set of principles introduced by Robert C. Martin (Uncle Bob). Clean Architecture organizes code into concentric
layers, with business logic at the center and external concerns (databases, frameworks, UI) at the periphery.

We don't strictly follow the Clean Architecture principles. We use three main layers:

```
┌─────────────────────────────────────────────────────┐
│                   Handlers Layer                    │
│                    (handlers/)                      │
│                                                     │
│  • Request parsing, validation, response formatting │
└──────────────────────────┬──────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────┐
│                    Service Layer                    │
│                     (services/)                     │
│                                                     │
│  • Business logic, orchestration                    │
│  • Transaction management                           │
│  • Input validation, error handling                 │
└──────────────────────────┬──────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────┐
│                  Data Access Layer                  │
│                       (dao/)                        │
│                                                     │
│  • External data source abstraction                 │
│  • Query execution and response mapping             │
└──────────────────────────┬──────────────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        ▼                  ▼                  ▼
   PostgreSQL            LLMs          Other sources
```

Two additional (but optional) layers may also be used:

- `/lib` for shared code that does not belong to a specific layer.
  - This layer should be kept minimal. If any of its members is to be duplicated among multiple projects,
    make sure it does not already exist in the shared [golib](https://github.com/a-novel-kit/golib).
    Otherwise, add a `#TODO` to move it there at some point.
- `/models` for shared definitions and data structure (mails, migrations, enums, etc.)
  - Only shared go types should live at the root of the `/models` layer. Other data structures should be placed
    inside a descriptive subfolder (`/models/mails`, `/models/migrations`, etc.)

### The Dependency Rule

The foundational principle of Clean Architecture is the **Dependency Rule**:

> Source code dependencies can only point inwards.

Inner layers take care of the implementation details, while outer layers abstract them through a mockable interface.

Each layer exposes its members as what we call "exec structs" i.e., structs with a single public method called `Exec`.
Those `Exec` methods usually take a context and a locally defined request struct as parameters. It should return a
business object, which may be defined locally or shared with other methods under the same layer.

```go
package layer

import (
	"context"
)

type MyMethodRequest struct {
	// ...
}

type MyMethod struct {
	// ... Dependencies
}

func (layer *MyMethod) Exec(ctx context.Context, request *MyMethodRequest) (*BusinessEntity, error) {
	// Implementation.
}
```

To declare dependencies, a method must create its own interfaces. Those interfaces are mocked using
[mockery](https://github.com/vektra/mockery) (more about that in the [unit tests documentation](./3.testing.md)).
The provided interfaces must match the signature of the lower layer (importing definitions from bottom to top is
allowed). Those interfaces must be properly prefixed with the method name:

```go
package layer

type MyMethod[Layer][ImportedMethod] interface {
	Exec(...)
}
```

For example:

```go
package layer

// [ModuleCreate] => name of the current method
// [Repository] => refers to the DAO layer
// [ModuleExists] => refers to the Delete method of the Repository layer
//
// This would create a dependency on the ModuleExists DAO from the ModuleCreate
// service.
type ModuleCreateRepositoryModuleExists interface {
	Exec(...)
}
```

Note that name can be shortened if the layers business targets match.

```go
package layer

// Module and Workflow are different business targets, keep name full.
type ModuleCreateRepositoryWorkflowExists interface {
	Exec(...)
}

// In place of ModuleCreateRepositoryModuleExists, since both the dependency
// and the service operate on the Module entity.
type ModuleCreateRepositoryExists interface {
	Exec(...)
}

// If the ModuleCreate service depends on the ModuleCreate repository,
// then the suffix may be omitted entirely.
type ModuleCreateRepository interface {
	Exec(...)
}
```

#### External connections

Dependencies MUST BE internal, except in the `/pkg` files. However, some layers may require connections, i.e.,
interact with separate services (that must be run as part of the containerized processes). Those connections (postgres,
openai, etc.) are not methods of a layer, so they cannot be mocked the conventional way.

For this case, a connection must be passed through the context.

> Passing connections through the context allows a different kind of mocking, by injecting a connection with the
> desired parameters, without any control from the layer itself. For example, the context may expect a postgres
> connection; whether this connection is a direct connection or a transactional one is up to the caller.
> Production code can use direct connections, and tests can provide a transaction that can be safely rolled back,
> once the test is over.

Each connection should provide dedicated helpers for initialization and interactions. Those helpers can either be
retrieved from an external package or loaded from the `/lib` layer.

```go
// Use tx to perform queries.
tx, err := postgres.GetContext(ctx)
```

### Layer factories

Each layer provides a factory method to create its exec structs. This prevents the need for dependencies to be exposed
onto the main struct (which could also lead to side effects if those are unintentionally modified at runtime).

```go
package layer

type MyMethodDependency1 interface {
	// ... Dependencies
}

type MyMethodDependency2 interface {
	// ... Dependencies
}

type MyMethod struct {
	dependency1 MyMethodDependency1
	dependency2 MyMethodDependency2
}

func NewMyMethod(
	dependency1 MyMethodDependency1,
	dependency2 MyMethodDependency2,
) *MyMethod {
	return &MyMethod{
		dependency1: dependency1,
		dependency2: dependency2,
	}
}
```

### Naming

Naming methods is less restricted, but usually one exec struct will operate a simple operation over a single
business object / entity. So the recommended naming scheme is `[Entity][Action]`: `UserList`, `ModuleCreate`, etc.

Files should be named after the exec struct they define. For example, the `ModuleCreate` struct should live inside
the `moduleCreate.go` file.

Some layers have huge ties to a particular dependency. For example, DAO structs are either tied to a database
(postgres, redis) or another source (ai). To help with debugging, the relevant dependency can be used as a prefix
to the file name.

- `ai.[method].go`, `postgres.[method].go` for the DAO
- `http.[method].go`, `grpc.[method].go` for the handlers

### Linkage

Dependencies are never directly linked in the code. Instead, the main routine is responsible for calling the factories
for each layer and branching on the result.

Linkage may happen in:

- The main functions (located under `cmd/`, they are run as part of the containerized processes)
- Mocks inside test files (see [unit tests documentation](./3.testing.md))
- Inside the exported libraries (`/pkg`). In this case (and this case only), the required dependencies may exist outside
  the layers entirely (external instances).

## Layer specifics

### DAO

The lowest layer, used to interact with data sources. Albeit not always true, this data source is most often postgres.

For postgres, we use [bun](https://bun.uptrace.dev/guide/), an ORM that has the benefit of integrating many tools under
the same package (struct serialization, migrations, etc.).

> About ORMs: we choose not to use bun query builder and instead rely on raw postgres queries. ORMs have a lot of
> drawbacks that are not worth the added complexity. We also want to prevent building our own internal ORM (which a
> lot of anti-ORM companies end up doing anyway). Queries are written in SQL, and bun is only used for its other
> capabilities (namely, struct serialization / deserialization, and migrations). The query builder is still used in
> tests, for simplicity.

DAO revolves around schemas, and operations on those schemas. The first step is to define a model for a given table,
and implement [bun models](https://bun.uptrace.dev/guide/models.html) on them. The DAO file structure should resemble
this:

```txt
- dao/
  - pg.[entity].go
  - pg.[entity][action].sql
  - pg.[entity][action].go
```

Where action is an operation (insert, update, exists, list, search, etc.). The `pg.[entity][action].go` will usually
look like this:

```go
package dao

import (
	"context"
	_ "embed"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/uptrace/bun/driver/pgdriver"
	"go.opentelemetry.io/otel/attribute"

	"github.com/a-novel-kit/golib/otel"
	"github.com/a-novel-kit/golib/postgres"
)

//go:embed pg.[entity][action].sql
var entityActionQuery string

type EntityActionRequest struct {
	// ...
}

type EntityAction struct{}

func NewEntityAction() *EntityAction {
	return new(EntityAction)
}

func (repository *EntityAction) Exec(
				ctx context.Context, request *EntityActionRequest,
) (*[entity], error) {
	ctx, span := otel.Tracer().Start(ctx, "dao.entityAction")
	defer span.End()

	span.SetAttributes(
		// ...
	)

	tx, err := postgres.GetContext(ctx)
	if err != nil {
		return nil, otel.ReportError(span, fmt.Errorf("get transaction: %w", err))
	}

	entity := new([entity])

	err = tx.NewRaw(
		entityActionQuery,
		// ...
	).Scan(ctx, entity)
	if err != nil {
		// ... Handle errors.

		return nil, otel.ReportError(span, fmt.Errorf("execute query: %w", err))
	}

	return otel.ReportSuccess(span, entity), nil
}
```

- Embed the query file
- Load span
- Load transaction from context
- Create entity
- Execute query and retrieve entity
- Return results
