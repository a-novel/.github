# Packaging

This document describes how services expose reusable logic to external consumers through the `/pkg` directory.

## Overview

Go's `internal/` convention prevents external modules from importing a service's layers directly. The `/pkg`
directory acts as the **public API surface** of a service: it selectively re-exports internal types, wires
internal layers together, and provides ready-to-use clients or utilities for external consumers.

```
External consumer
       │
       ▼
    /pkg          ← public API (importable by other modules)
       │
       ├── internal/services
       ├── internal/handlers/protogen
       ├── internal/handlers/middlewares
       └── internal/config
            ← internal layers (not importable externally)
```

> As described in the [layers documentation](./2.layers.md#linkage), `/pkg` is the only place (besides `cmd/`
> and test files) where cross-layer wiring is allowed. Dependencies may exist outside the layers entirely.

## Type re-exports

Internal types that need to be part of the public API are re-exported via type aliases:

```go
package pkg

import (
	"[project]/internal/config"
	"[project]/internal/services"
)

type Role = config.Role
type Permissions = config.Permissions
type Claims = services.AccessTokenClaims
```

External consumers use `pkg.Role`, `pkg.Claims`, etc. — they never import `internal/` directly. Only re-export
types that are genuinely needed by consumers.

### gRPC client

gRPC definitions and stubs are, like all layers, hidden inside the `/internal` directory. Since gRPC is meant for
service-to-service communication, it must be exposed to external consumers. `/pkg` is the place to go.

#### Client interface

Define a public interface covering all RPC methods, plus any additional accessors for pre-configured resources:

```go
package pkg

type BaseClient interface {
	Status(ctx context.Context, req *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	EntityGet(ctx context.Context, req *EntityGetRequest, opts ...grpc.CallOption) (*EntityGetResponse, error)
	EntityList(ctx context.Context, req *EntityListRequest, opts ...grpc.CallOption) (*EntityListResponse, error)
	Close()
}

type Client interface {
	BaseClient
	Sources() *PublicSources
	Recipients() Recipients
}
```

`BaseClient` contains the raw RPC methods (one per proto service). `Client` extends it with domain-specific
accessors built from the RPC data.

#### Client struct

The private struct embeds the generated gRPC service clients, satisfying `BaseClient` automatically:

```go
type client struct {
	protogen.StatusServiceClient
	protogen.EntityGetServiceClient
	protogen.EntityListServiceClient

	sources    *PublicSources
	recipients Recipients

	conn *grpc.ClientConn
}

func (c *client) Sources() *PublicSources { return c.sources }
func (c *client) Recipients() Recipients  { return c.recipients }
func (c *client) Close()                  { _ = c.conn.Close() }
```

#### Constructor

The constructor dials the gRPC connection, creates the sub-clients, and wires any higher-level services:

```go
func NewClient(addr string, opts ...grpc.DialOption) (Client, error) {
	conn, err := grpc.NewClient(addr, opts...)
	if err != nil {
		return nil, fmt.Errorf("dial: %w", err)
	}

	c := &client{
		StatusServiceClient:    protogen.NewStatusServiceClient(conn),
		EntityGetServiceClient: protogen.NewEntityGetServiceClient(conn),
		// ...
		conn: conn,
	}

	// Wire higher-level services using internal constructors.
	c.sources = services.NewPublicSource(newAdapter(c), config.Preset)
	c.recipients = services.NewRecipients(c.sources, config.Preset)

	return c, nil
}
```

This is where `/pkg` breaks the dependency rule: it imports internal services, config, and protogen to wire
everything into a single consumer-facing constructor.

#### Adapters

When an internal service expects a domain interface but the client speaks in protobuf, an adapter bridges the
gap:

```go
type entityExportGrpc struct {
	client BaseClient
}

func (api *entityExportGrpc) SearchEntities(ctx context.Context, usage string) ([]*domain.Entity, error) {
	// Call the gRPC client.
	res, err := api.client.EntityList(ctx, &EntityListRequest{Usage: usage})
	if err != nil {
		return nil, err
	}

	// Map protobuf types to domain types.
	return lo.Map(res.GetEntities(), func(e *protogen.Entity, _ int) *domain.Entity {
		return &domain.Entity{
			ID:   e.GetId(),
			Name: e.GetName(),
		}
	}), nil
}
```

This allows internal services (like token verification) to work **client-side**, consuming keys fetched over
gRPC rather than from a local database.

#### Protobuf type re-exports

Re-export all request/response types so consumers do not need to import protogen:

```go
type StatusRequest = protogen.StatusRequest
type StatusResponse = protogen.StatusResponse
type EntityGetRequest = protogen.EntityGetRequest
type EntityGetResponse = protogen.EntityGetResponse
```

## Testing

`/pkg` tests are **integration tests** — they exercise the full client against a running instance of the
service. They live in the `pkg_test` package:

```go
package pkg_test

func TestClient(t *testing.T) {
	client, err := pkg.NewClient(testAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	require.NoError(t, err)
	defer client.Close()

	// Exercise RPC methods against the live server.
	res, err := client.EntityList(t.Context(), &pkg.EntityListRequest{Usage: "test"})
	require.NoError(t, err)
	require.NotEmpty(t, res.GetEntities())
}
```

These tests validate that the client wiring, adapter conversions, and type re-exports work correctly end-to-end.
