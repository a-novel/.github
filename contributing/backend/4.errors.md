# Error Handling

This document describes how errors are created, propagated, and mapped across the three-layer architecture.

## Overview

Errors flow upwards through the layers. Each layer has a specific role:

```
┌──────────────────────────────────────────────────────────────────────┐
│ Handlers                                                             │
│  Map sentinel errors to protocol status codes (HTTP, gRPC).          │
│  Never expose raw error messages to the client.                      │
└───────────────────────────────┬──────────────────────────────────────┘
                                │  errors.Is(err, sentinel)
┌───────────────────────────────▼──────────────────────────────────────┐
│ Services                                                             │
│  Validate requests, enforce business rules, wrap errors with context.│
└───────────────────────────────┬──────────────────────────────────────┘
                                │  fmt.Errorf("operation: %w", err)
┌───────────────────────────────▼──────────────────────────────────────┐
│ DAO                                                                  │
│  Detect driver-specific errors, join them with sentinel errors.      │
└──────────────────────────────────────────────────────────────────────┘
```

## Sentinel errors

Every layer defines its own sentinel errors using `errors.New`. A sentinel error is a package-level variable
that represents a specific, expected failure condition.

```go
var ErrEntityNotFound = errors.New("entity not found")
```

Naming convention: `Err[Method][Condition]` — e.g., `ErrCredentialsInsertAlreadyExists`,
`ErrShortCodeConsumeExpired`.

Sentinels are always checked using `errors.Is()`, which traverses the full error chain (wrapped and joined
errors). This is what allows handlers to detect a DAO sentinel that was wrapped multiple times on its way up.

## Error composition

Two mechanisms are used to compose errors, each with a distinct purpose.

### `fmt.Errorf` — contextual wrapping

Adds a human-readable prefix while preserving the error chain. Used to describe **what operation failed**:

```go
return nil, fmt.Errorf("insert credentials: %w", err)
```

The `%w` verb wraps the original error: `errors.Is(result, originalErr)` still succeeds.

### `errors.Join` — sentinel classification

Combines two independent errors as peers. Used to **tag an error with a sentinel** without establishing a
parent-child relationship:

```go
err = errors.Join(err, ErrEntityNotFound)
```

Both errors remain individually detectable via `errors.Is()`.

> **Rule of thumb**: use `fmt.Errorf("%w")` when adding context to an error, use `errors.Join` when classifying
> an error with a sentinel.

## DAO

The DAO layer translates driver-specific errors into domain sentinels. Two patterns cover most cases.

### Not-found detection

When a query returns no rows, `sql.ErrNoRows` is joined with a descriptive sentinel:

```go
if errors.Is(err, sql.ErrNoRows) {
	err = errors.Join(err, ErrEntitySelectNotFound)
}

return nil, fmt.Errorf("execute query: %w", err)
```

### Unique violation detection

PostgreSQL unique constraint violations are detected via the pgdriver error code `23505`:

```go
var pgErr pgdriver.Error
if errors.As(err, &pgErr) && pgErr.Field('C') == "23505" {
	err = errors.Join(err, ErrEntityInsertAlreadyExists)
}

return nil, fmt.Errorf("execute query: %w", err)
```

`errors.As` extracts the concrete `pgdriver.Error` type, allowing inspection of PostgreSQL error fields.

## Services

### Validation errors

Services validate requests using `go-playground/validator`. When validation fails, the validator error is joined
with `ErrInvalidRequest`:

```go
err := validate.Struct(request)
if err != nil {
	return nil, errors.Join(err, ErrInvalidRequest)
}
```

`errors.Join` is used (not `fmt.Errorf`) so that both the detailed field-level validation errors and the
`ErrInvalidRequest` sentinel are preserved as peers.

### Business rule errors

Services define their own sentinels for domain-specific violations:

```go
var (
	ErrUpdateRoleSelfUpdate        = errors.New("user is not allowed to update its own role")
	ErrUpdateRoleDowngradeSuperior = errors.New("user can only downgrade users from a lower role")
)
```

These are returned directly (optionally wrapped with context via `fmt.Errorf`):

```go
return nil, fmt.Errorf(
	"%w: upgrade from %s to %s",
	ErrUpdateRoleToHigher, currentRole, targetRole,
)
```

### Wrapping lower-layer errors

Every call to a dependency is wrapped with `fmt.Errorf` to provide a breadcrumb trail:

```go
credentials, err = service.repository.Exec(ctx, request)
if err != nil {
	return nil, fmt.Errorf("insert credentials: %w", err)
}
```

Inside transactions, an additional wrapping layer is added:

```go
err = postgres.RunInTx(ctx, nil, func(ctx context.Context, tx bun.IDB) error {
	_, err = service.serviceCodeConsume.Exec(ctx, &CodeConsumeRequest{...})
	if err != nil {
		return fmt.Errorf("consume code: %w", err)
	}

	return nil
})
if err != nil {
	return nil, fmt.Errorf("run transaction: %w", err)
}
```

The resulting error chain (e.g., `"run transaction: consume code: execute query: <joined: sql.ErrNoRows +
ErrShortCodeSelectNotFound>"`) remains fully traversable by `errors.Is()`.

### Conditional sentinel joining

When a lower-layer error needs to be reclassified at the service level, the service checks for the specific
error and joins it with its own sentinel:

```go
if errors.Is(err, jws.ErrInvalidSignature) {
	return nil, errors.Join(err, ErrTokenRefreshInvalidAccessToken)
}

return nil, fmt.Errorf("verify token: %w", err)
```

## Handlers

Handlers are the only layer that translates errors into protocol-level status codes. The raw error message is
**never sent to the client** — only the generic status text (e.g., `"Not Found"`, `"Internal Server Error"`)
is returned. The actual error is logged server-side.

### HTTP — `httpf.ErrMap`

HTTP handlers use `httpf.HandleError` from [golib](https://github.com/a-novel-kit/golib). It takes an `ErrMap`
(`map[error]int`) that maps sentinel errors to HTTP status codes:

```go
httpf.HandleError(ctx, handler.logger, w, nil, httpf.ErrMap{
	services.ErrInvalidRequest:            http.StatusUnprocessableEntity,
	dao.ErrCredentialsInsertAlreadyExists: http.StatusConflict,
	dao.ErrShortCodeSelectNotFound:        http.StatusForbidden,
}, err)
```

Matching rules:

- Each key is tested against the error using `errors.Is()`.
- A `nil` key overrides the default status code (which is `500` otherwise).
- If no key matches and no `nil` key is present, the response defaults to `500 Internal Server Error`.

The `nil` key is typically used for request decoding errors:

```go
httpf.HandleError(ctx, handler.logger, w, nil, httpf.ErrMap{nil: http.StatusBadRequest}, err)
```

### gRPC — `status.Error`

gRPC handlers match errors explicitly with `errors.Is()` and return the appropriate gRPC status:

```go
if errors.Is(err, dao.ErrEntitySelectNotFound) {
	return nil, status.Error(codes.NotFound, "entity not found")
}
if err != nil {
	return nil, status.Error(codes.Internal, "internal error")
}
```

The message passed to `status.Error` is a short, non-sensitive description. Any unmatched error returns
`codes.Internal`.

## Security: anti-enumeration

Some endpoints intentionally obscure error responses to prevent information leakage.

### Identical statuses for distinct errors

Login handlers map both "user not found" and "wrong password" to the same status, so the client cannot
distinguish between the two:

```go
httpf.ErrMap{
	dao.ErrCredentialsSelectByEmailNotFound: http.StatusUnauthorized,
	lib.ErrInvalidPassword:                  http.StatusUnauthorized,
}
```

### Swallowed errors

Short code creation handlers (register, password reset, email update) silently return a success status when the
email is already taken or does not exist. The client receives `202 Accepted` regardless:

```go
if err != nil {
	if !errors.Is(err, dao.ErrCredentialsInsertAlreadyExists) {
		httpf.HandleError(ctx, handler.logger, w, nil, httpf.ErrMap{...}, err)
		return
	}
}

w.WriteHeader(http.StatusAccepted)
```

The error is detected, but only non-swallowed errors trigger the error handler. The swallowed case falls
through to the normal success response.
