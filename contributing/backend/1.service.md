# Services

A-Novel is built on top of services.

> A service is **one or many APIs, all related to the same business feature**.

## Service versus Microservice versus Monolith

Historically, applications tend to serve a single API for their entire domain. While this approach is straightforward
and efficient (codewise), it becomes cumbersome to maintain over large applications.

A common solution to this was to split the monolithic API into multiple, separated services that would each serve
only a subset of the domain. This adds the benefits of better maintainability and scalability and also allows for
some deployment flexibility.

Now, there is service, and there is microservice (some even talk about nanoservice). They all work the same, the
difference is about how granular you are willing to go with the separation. Since the microservice introduction,
there’s been a tendency to go more and more granular, leading to dozens or hundreds of basic services, with very few
endpoints.

This seems to be the perfect approach, theoretically speaking. However, microservice bloating tends to cancel the
maintainability benefits from breaking the monolith in the first place. More services means more repositories,
more CIs, and makes large-scale upgrades (such as a core technology upgrade) basically impossible past some point
(let’s just upgrade those three very used services and never touch the rest ever again).

Another (major) drawback of micro/nano services is the unavoidable necessity for gateways / orchestrators. Because
microservice splitting occurs on a technical, non-business level, operations involving multiple services are common,
and often require their own dedicated structures to handle them properly and safely.

### The A-Novel approach

Having quite some experience with both monoliths and nanoservices, I chose not to go with any of them. Instead, I went
with the "services" approach: break the monolith only when parts of it can be **fully decoupled** from the rest.
Full decoupling implies splitting things at the business level because different business features are very unlikely
to heavily rely on each other because they are separated from the design phase.

This does not mean that no code is shared or that services never rely on each other (in fact, there are notable
exceptions like the authentication service). It means that each service is designed to be fully autonomous when it
comes to business logic, and **multiservice workflows must be runnable asynchronously and safely, from a client**.

## Interacting with services

Each service can expose one to two APIs, depending on the target usage:

- **REST API**: The most commonly exposed API, exposes rest endpoints that can be consumed by any client.
  Such an api will come with a [public OpenAPI doc](https://swagger.io/specification/), and will usually export
  dedicated packages for the targeted clients ecosystems.
- **gRPC service**: more rarely used, this kind of API is designed for internal communication between services,
  providing less security at the expense of performance. We don't use gRPC as our main communication protocol,
  because [browsers can't support it](https://grpc.io/blog/state-of-grpc-web/#the-grpc-web-spec).

Since each type of API serves its own purpose, it is perfectly possible (and accepted) to have duplicated routes
in both, if needed.

## Deploying / running services locally

Each service runs on its own stack, which includes:

- The service itself
- Dependencies (database, mailer, etc...)
- Patches (optional, sets up dependencies before / after the main service starts)
  - Usually, each service will include at least one `migrations` patch to setup the database schemas.

Each element of this stack comes as its own docker image, so you can run it in any environment that supports
containerization. Dependencies must be up and serving for the service to run. Patches won't prevent service from
starting up; however, they may be required at least once for the endpoints to execute properly.

### Versioning

Docker images follow git semantic versioning, where a new version is created every time a new tag is pushed to
the repository.

```yaml
# Main service
image: ghcr.io/a-novel/[service]/rest:v1.0.0

# Dependencies (should be mounted before)
image: ghcr.io/a-novel/[service]/database:v1.0.0
image: ghcr.io/a-novel/[service]/migrations:v1.0.0
# ...
image: ghcr.io/a-novel/[service]/otherPatch:v1.0.0
```

Unversioned images are also available for every branch and commit (feature envs). They can be used to run unstable
versions locally, or in a stage environment. However, production should only pull versioned images.

```yaml
# Tagged version
image: ghcr.io/a-novel/[service]/rest:v1.0.0
# Branch version
image: ghcr.io/a-novel/[service]/rest:feature-branch
# Commit version
image: ghcr.io/a-novel/[service]/rest:sha256:6f26f6ffaba8471c1e83eec1cc53032909683d55afc3a879c30d8267e395a179
```

Version is also synced for all the images of the same service. You should not mix versions for the same service.

```yaml
# ✅ Do
image: ghcr.io/a-novel/[service]/rest:v1.0.0
image: ghcr.io/a-novel/[service]/database:v1.0.0

# ❌ Don't
image: ghcr.io/a-novel/[service]/rest:v1.0.0
image: ghcr.io/a-novel/[service]/database:v1.0.1
```

### Packages

Services may export various packages for their clients. Packages aim to prevent duplication of definitions and
ensure proper type safety. This may include:

- A go package: `go get -u github.com/a-novel/[service]/pkg`, usually targeted at other services. Is used to expose
  shared logic and data structures. It does not always require a running service.
- A JavaScript REST package: `pnpm i @a-novel/[service]/rest-js`, provides type-safe handlers for interacting
  with the REST api.

The README of each service will provide a guide on how to use these packages.
